"""
ПРАКТИЧЕСКОЕ ЗАДАНИЕ
2023/11/30 00:00|Домашнее задание по теме "Генерация функций"
Домашнее задание по уроку Генерация функций.
Цель задания:
Научиться создавать функции динамически в зависимости от заданных условий и параметров, используя различные подходы, такие как фабрики функций, лямбда-функции и вызываемые объекты.
Теоретический комментарий:
1. Динамическое определение функций (def):
В Python можно определять функции внутри других функций. Такие функции могут создаваться и возвращаться. Это основа для создания "фабрик функций" - функций, создающих функции.

2. Лямбда-функции:
Лямбда-функции в Python — это анонимные функции, определённые одной строкой. Они удобны для создания простых функций на лету, особенно когда функция нужна временно или для одноразового использования.

3. Вызываемые объекты (__call__):
В Python у класса может быть метод __call__, что позволяет его экземплярам вести себя как функции. Это дает возможность создавать объекты, которые могут быть вызваны как функции и хранить состояние между вызовами.
Задание:
Задача 1: Фабрика Функций
Написать функцию, которая возвращает различные математические функции (например, деление, умножение) в зависимости от переданных аргументов.

Задача 2: Лямбда-Функции
Использовать лямбда-функцию для реализации простой операции и написать такую же функцию с использованием def. Например, возведение числа в квадрат

Задача 3: Вызываемые Объекты
Создать класс с Rect c полями a, b которые задаются в __init__ и методом __call__, который возвращает площадь прямоугольника, то есть a*b.
"""


def create_operation(operation):
    if operation == '+':
        return lambda x, y: x + y
    if operation == '++':
        return lambda *x: sum(x)
    if operation == '-':
        return lambda x, y: x - y
    if operation == '--':
        return lambda *x: print(eval('-'.join(map(str, x))))
    if operation == '*':
        return lambda x, y: x * y

    if operation == '**':
        return lambda *x: print(eval('*'.join(map(str, x))))



a = create_operation('+')
print(a(12, 17))

a = create_operation('++')
print(a(2, 6, 7, 8, 45, -100))

a = create_operation('-')
print(a(12, 17))

a = create_operation('--')
print(a(2, 6, 7, 8, 45, -100))

a = create_operation('*')
print(a(12, 17))

a = create_operation('**')
print(a(2, 6, 7, 8, 45, -100))

class Rect:
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def __call__(self, *args, **kwargs):
        if args:
            self.__init__(args[0],args[1])
        return self.a * self.b


rect1 = Rect(3, 6)
print(rect1())
print(rect1(5,9))
print(rect1())
print(rect1(77,33))

